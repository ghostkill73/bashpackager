#!/usr/bin/env bash
#################################################################
# Author : Abner Benedito
# Version: 1.0
# License: 0-BSD
#################################################################

#################################################################
# Configs
#################################################################

declare -i TRUE=0 # exit status for success.
declare -i FALSE=1 # exit status for recognized error."
declare -i ERROR=2 # exit status for not recognized error."

case "$BASH_VERSION" in
    [4-9].*) : ;; # pass
    *)
        printf '\e[1;31merror:\e[m Bash version >=4.0 required, but you have %s\n' "$BASH_VERSION"
        exit $FALSE
    ;;
esac

declare -- __SETUP_PWD__="$PWD"
declare -- __SETUP_FILENAME__="setup.cfg"
declare -- __SETUP_FILE__="${__SETUP_PWD__}/${__SETUP_FILENAME__}"

#################################################################
# Utils
#################################################################

function __Message() {
    local content="$*"

    printf '%b\n' "$content" >&2
}

function __FatalError() {
    local errorMessage="$*"

    __Message "\e[1;31mfatal error:\e[m $errorMessage"

}

function __Regex() {
    local text="$1"
    local compile="$2"

    [[ $text =~ $compile ]]
}

#################################################################
# main
#################################################################


function __GetConfigValues() {
    local -a setupFileLine
    local -a ___INVALID_CONFIG

    declare -g __SCRIPT_NAME__ __SCRIPT_VERSION__ __SCRIPT_DESC__
    
    # reading setup file
    while IFS= read -r readLine; do
        [[ -z "$readLine" ]] && continue
        setupFileLine+=("$readLine")
    done < "$__SETUP_FILE__"

    for line in "${setupFileLine[@]}"; {
        case "${line,,}" in
            'name'*)
                __Regex "$line" "name:\\s+(.+)[,]"
                __SCRIPT_NAME__="${BASH_REMATCH[1]}"
            ;;
            'version'*)
                __Regex "$line" "version:\\s+(.+)[,]"
                __SCRIPT_VERSION__="${BASH_REMATCH[1]}"
            ;;
            'desc'*)
                __Regex "$line" "desc:\\s+(.+)[,]"
                __SCRIPT_DESC__="${BASH_REMATCH[1]}"
            ;;
            '#'*) : ;; # comments
            *)
                ___INVALID_CONFIG+=("$line")
            ;;
        esac

        # resetting BASH_REMATCH value
        [[ "${null:=}" =~ '' ]] || :
    }

    # error for invalid options
    (( ${#___INVALID_CONFIG[@]} > 0 )) && {
        __FatalError "The following options in ${__SETUP_FILENAME__} are not valid:"
        for _invalid in "${___INVALID_CONFIG[@]}"; {
            __Message " -- $_invalid"
        }
        exit $FALSE
    }
}

__GetConfigValues
echo $__SCRIPT_NAME__
echo $__SCRIPT_VERSION__
echo $__SCRIPT_DESC__

# function import
# {
# 	# import a script based on BASHPACKAGERPATH
# 	local module="$1"
# 	local old_ifs="$IFS"
# 	local path _path
# 	local path_count import_error_count

# 	declare -i import_error_count=0
# 	declare -a path

# 	IFS=':' read -ra path <<< "$BASHPACKAGERPATH"
# 	IFS="$old_ifs"

# 	declare -i path_count="${#path[@]}"

# 	for _path in "${path[@]}"
# 	{
# 		[[ -d "$_path/$module" ]] ||
# 		{
# 			import_error_count+=1
# 			continue
# 		}

# 		[[ -e "$_path/$module/bp_main" ]] ||
# 		{
# 			__error "-- $SCRIPTNAME: \"bp_main\" not found in module \"$module\"."
# 		}

# 		source "$_path/$module/bp_main" && break
# 	}

# 	((import_error_count == path_count)) &&
# 		__error "-- $SCRIPTNAME: module \"$module\" not found."
# }

# (($# == 0)) && __display_usage

# if [[ -f "$1" ]]; then
# 	declare SCRIPTNAME="$1"
# 	source "$1"
# else
# 	__error "$1 not exists."
# fi
